load(":utils.bzl", "EXECUTE_TIMEOUT", "PYTHON_EXT_MAP", "get_os", "get_path_envar")

# This excluded violating file is from arrow-cpp 10.0.1 in Snowflake Anaconda Channel.

BUILD_FILE_CONTENT = """# This file was automatically generated by rules_conda
package(default_visibility = ["//visibility:public"])

load("@bazel_tools//tools/python:toolchain.bzl", "py_runtime_pair")

py_runtime(
    name = "{name}",
    files = glob(["{env_path}/**/*"], exclude=["{env_path}/share/gdb/auto-load/**"], exclude_directories = 0),
    interpreter = "{env_path}/{interpreter_path}",
    python_version = "PY{py_major}",
    coverage_tool = {coverage_tool_target},
)

filegroup(
    name={coverage_tool_target},
    srcs=["{coverage_tool_path}"]
)
"""

def _conda_cmd(rctx, conda_args, environment = {}):
    path_envar = get_path_envar(rctx)
    os = get_os(rctx)
    conda_entrypoint = Label("@{}//:{}/micromamba".format(
        rctx.attr.conda_repo,
        rctx.attr.conda_dir,
    ))

    actual_environment = {"PATH": path_envar}
    actual_environment.update(environment)

    return rctx.execute(
        # all environment variables are stripped. PATH and environment variables passed in are
        # added above. this is to prevent the conda_entrypoint from recognizing the conda
        # environment (if any) where bazel was invoked.
        [conda_entrypoint, "--root-prefix", "./"] + conda_args,
        quiet = rctx.attr.quiet,
        environment = actual_environment,
        timeout = rctx.attr.timeout,
    )

# clean conda caches and unused packages
def _clean(rctx):
    rctx.report_progress("Cleaning up")

    result = _conda_cmd(rctx, ["clean", "-a", "-y"])
    if result.return_code:
        fail("Failure cleaning up.\nstdout: {}\nstderr: {}".format(result.stdout, result.stderr))

def _create_empty_environment(rctx, env_name):
    rctx.report_progress("Creating empty conda environment, to be populated afterwards")
    result = _conda_cmd(rctx, ["create", "-y", "-c", "https://repo.anaconda.com/pkgs/snowflake", "--override-channels", "-p", "./{}".format(env_name), "python={}".format(rctx.attr.python_version)])
    if result.return_code:
        fail("Failure creating empty environment.\nstdout: {}\nstderr: {}".format(result.stdout, result.stderr))

def _update_environment(rctx, env_name, env_file):
    rctx.report_progress("Updating empty conda environment to populate it")
    result = _conda_cmd(
        rctx,
        ["install", "-y", "-f", env_file, "-p", "./{}".format(env_name)],
        environment = {"MAMBA_USE_LOCKFILES": "false"},
    )
    if result.return_code:
        fail("Failure updating environment.\nstdout: {}\nstderr: {}".format(result.stdout, result.stderr))

# create new local conda environment from file
def _create_environment(rctx, env_name):
    rctx.report_progress("Creating conda environment")

    # path to env file as string
    env_file = rctx.path(rctx.attr.environment)

    _create_empty_environment(rctx, env_name)
    _update_environment(rctx, env_name, env_file)

# get installed python version
def _get_py_version(rctx, env_path, interpreter_path):
    interpreter = "{}/{}".format(env_path, interpreter_path)
    result = rctx.execute([rctx.path(interpreter), "--version"], timeout = rctx.attr.timeout)
    output = result.stdout if result.stdout else result.stderr
    return output.replace("Python ", "")

# get major version number
def _get_major(version):
    return int(version.partition(".")[0])

# create BUILD file with py_runtime
def _create_env_build_file(rctx, env_name):
    os = get_os(rctx)
    python_executable = "python{}".format(PYTHON_EXT_MAP[os])
    interpreter_path = python_executable if os == "win" else "bin/{}".format(python_executable)

    py_version = _get_py_version(rctx, env_name, interpreter_path)
    py_major = _get_major(py_version)

    if py_major != 3:
        fail("Only Python 3 is supported. Your Python version is: {}.".format(py_version))

    # We replace the coverage tool with our own wrapper, to injects a --ignore-errors argument when called to generate
    # a coverage report, to avoid bazel fails when running coverage tool to collect coverage report on a source code
    # file that does not exist, for example, zip-imported source.
    # The original coverage tool is {env_name}/bin/coverage.
    coverage_tool_path = "{}/bin/coverage_tool.py".format(env_name)
    coverage_tool_target = "\"coverage_tool\""

    coverage_tool_label = rctx.attr.coverage_tool
    coverage_tool_content = rctx.read(coverage_tool_label)

    coverage_tool_header = "#!{interpreter_path}\n\n".format(interpreter_path = rctx.path("{}/{}".format(env_name, interpreter_path)))
    rctx.file(
        coverage_tool_path,
        content = coverage_tool_header + coverage_tool_content,
    )

    rctx.file(
        "BUILD",
        content = BUILD_FILE_CONTENT.format(
            name = "python_runtime",
            env_path = env_name,
            interpreter_path = interpreter_path,
            py_major = py_major,
            coverage_tool_target = coverage_tool_target,
            coverage_tool_path = coverage_tool_path,
        ),
    )

def _conda_create_impl(rctx):
    env_name = rctx.attr.conda_env_name
    _create_environment(rctx, env_name)
    if rctx.attr.clean:
        _clean(rctx)
    _create_env_build_file(rctx, env_name)

conda_create_rule = repository_rule(
    _conda_create_impl,
    attrs = {
        "clean": attr.bool(
            default = False,
            doc = "True if conda cache should be cleaned",
        ),
        "conda_dir": attr.string(mandatory = True),
        "conda_env_name": attr.string(mandatory = True),
        "conda_repo": attr.string(mandatory = True),
        "coverage_tool": attr.label(
            allow_single_file = True,
            doc = "The label of the coverage_tool.py file.",
        ),
        "environment": attr.label(
            mandatory = True,
            allow_single_file = True,
            doc = "The label of the environment.yml file.",
        ),
        "python_version": attr.string(
            mandatory = True,
            doc = "The Python version to use when creating the environment.",
            values = ["3.8", "3.9", "3.10", "3.11"],
        ),
        "quiet": attr.bool(
            default = True,
            doc = "False if conda output should be shown",
        ),
        "timeout": attr.int(
            default = EXECUTE_TIMEOUT,
            doc = "Timeout in seconds for each execute action",
        ),
    },
)
